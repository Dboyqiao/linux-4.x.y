dev_t
========================================

path: include/linux/types.h
```
typedef __u32 __kernel_dev_t;
...
typedef __kernel_dev_t		dev_t;
```

因为历史原因，有两种方法可以管理设备的主从设备号（在一个复合数据类型中）。
在内核版本2.6开发期间，使用一个16位的整数（通常是unsigned short）来表示
主从设备号。该整数按1:1比例划分，8个比特位表示主设备号，8个比特位表示从设备
号。这意味着刚好有256个主设备号和256个从设备号可用。当前的有些系统规模远远
超出了上述的限制，我们只需要考虑SCSI存储阵列的例子即可，其中包含了数目非常
庞大的硬盘。

因而16位整数的定义被替换为32位整数（相关的抽象类型是dev_t）,
但这样做会有一些后果。我们意识到，16个比特位已经超出主设备号的需要。
因此，主设备号分配了12个比特位，剩余的20个比特位用于从设备号。
这引起了下述的问题:

* 许多驱动程序作出了不正确的假定，认为只有16个比特位可用来表示主从设备号;
* 存储在旧的文件系统上的设备文件号只使用了16个比特位，但仍然必须运作正确.

因此，必须解决现在对主从设备号占用比特位的非对称划分所引起的问题。
第一个问题可以通过修订驱动程序来消除，而第二个问题在更大程度上是本质性的。
为处理新的情况，内核使用了用户空间可见的数据类型u32来表示设备号，主从设备号
的划分如图所示:

https://github.com/novelinux/linux-4.x.y/tree/master/include/linux/types.h/res/dev_t.jpg

* 在内核中，比特范围0～19共20个比特位用于从设备号, 而比特范围20～31中的
12个比特位用于主设备号。
* 当需要在外部（用户空间）表示dev_t时，则将比特范围0～7中的8个比特位用作
从设备号的第一部分，接下来的12个比特位（比特范围8～19）用作主设备号，
最后12个比特位（比特范围20～31）用作从设备号剩余的部分。

旧的布局共包括16个比特位，在主从设备号之间平均分配。如果主设备号和从设备号
都小于255，那么新旧表示是兼容的。如果代码坚持使用在dev_t和外部表示之间进行
转换的函数，那么即使将来内部数据类型再次发生改变，代码也无需变动。这种划分
的优点在于，该数据结构的前16个比特位，可以解释为旧的设备号。从兼容性的角度
考虑，这是很重要的。

内核提供了下列函数/宏,以便从u32表示提取信息，并在u32和dev_t之间进行转换:

* MAJOR和MINOR分别从dev_t提取主设备号和从设备号.
* MKDEV(major, minor)根据主从设备号产生一个dev_t类型值.
* new_encode_dev将dev_t转换为具有上述外部表示的u32类型值.
* new_decode_dev将外部表示转换为dev_t.
* old_encode_dev和old_decode_dev在旧的u16表示和现在的dev_t表示之间进行切换.
