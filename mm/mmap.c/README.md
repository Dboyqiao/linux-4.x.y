Task Virtual Memory Layout
========================================

用户层进程的虚拟地址空间是Linux的一个重要抽象：
它向每个运行进程提供了同样的系统视图，这使得多个进程可以同时
运行，而不会干扰到其他进程内存中的内容。此外，它容许使用各种
高级的程序设计技术，如内存映射。这同样需要考察可用物理内存中
的页帧与所有的进程虚拟地址空间中的页之间的关联：逆向映射
（reverse mapping）技术有助于从虚拟内存页跟踪到对应的物理内存
页，而缺页处理（page faulthandling）则允许从块设备按需读取数据
填充虚拟地址空间。

如下方法通常是内核用于管理用户虚拟地址空间的方法:

* 每个应用程序都有自身的地址空间，与所有其它应用程序分离.

* 通常在巨大的线性地址空间中，只有很少的段可用于各个用户空间
  进程，这些段彼此之间有一定距离内核需要一些数据结构来有效管理
  这些随机分布的段.

* 地址空间只有极小的一部分与物理内存页直接关联。不经常使用的
  部分，仅当必要时与页帧关联.

* 内核信任自身，但无法信任用户进程。因此各个操作都伴随有各种
  检查，以确保程序的权限不会超出应有的限制，进而危机系统的稳
  定性和安全性.

Address Space
----------------------------------------

各个进程的虚拟地址空间起始于地址0，延伸到TASK_SIZE- 1，其上是
内核地址空间。在ARM系统上地址空间的范围可达232 = 4 GiB，总的
地址空间通常按3:1比例划分。内核分配了1 GiB，而各个用户空间进程
可用的部分为3 GiB。其他的划分比例也是可能的，只能在非常特定的
配置和某些工作负荷下才有用。与系统完整性相关的非常重要的一方面
是，用户程序只能访问整个地址空间的下半部分，不能访问内核部分。
如果没有预先达成“协议”，用户进程也不可能操作另一个进程的地址
空间，因为后者的地址空间对前者不可见。无论当前哪个用户进程处于
活动状态，虚拟地址空间内核部分的内容总是同样的。取决于具体的
硬件，这可能是通过操作各用户进程的页表，使得虚拟地址空间的
上半部看上去总是相同的。也可能是指示处理器为内核提供一个独立的
地址空间，映射在各个用户地址空间之上。虚拟地址空间由许多不同长度
的段组成，用于不同的目的，必须分别处理。例如在大多数情况下，
不允许修改text段，但必须可以执行其内容。另一方面，必须可以修改
映射到地址空间中的文本文件内容，而不能允许执行其内容。因为这
没有意义，文件的内容只是数据，并非机器代码。

Layout
----------------------------------------

虚拟地址空间中包含了若干区域，其分布方式是特定于体系结构的，
但所有方法都有下列共同的成分:

* 当前运行代码的二进制代码.该代码通常称之为text，所处的虚拟
  内存区域称之为text段;
* 程序使用的动态库的代码;
* 存储全局变量和动态产生的数据的堆;
* 用于保存局部变量和实现函数/过程调用的栈;
* 环境变量和命令行参数的段;
* 将文件内容映射到虚拟地址空间中的虚拟内存映射;

系统中的各个进程都具有一个struct mm_struct的实例，可以通过
task_struct访问。这个实例保存了进程的内存管理信息:

https://github.com/novelinux/linux-4.x.y/tree/master/include/linux/mm_types.h/mm_struct.md

下图说明了前述的各个部分在大多数体系结构的虚拟地址空间中的分布
情况:

https://github.com/novelinux/linux-4.x.y/tree/master/mm/mmap.c/res/old_layout.jpg

text段如何映射到虚拟地址空间中由ELF标准确定。每个体系结构
都指定了一个特定的起始地址。堆紧接着text段开始，向上增长。
栈起始于STACK_TOP，如果设置了PF_RANDOMIZE，则起始点会减少一个
小的随机量。每个体系结构都必须定义STACK_TOP，大多数都设置为
TASK_SIZE，即用户地址空间中最高的可用地址。进程的参数列表和
环境变量都是栈的初始数据。用于内存映射的区域起始于
mm_struct->mmap_base，通常设置为TASK_UNMAPPED_BASE，每个体系
结构都需要定义。几乎所有的情况下，其值都是TASK_SIZE/3。
要注意，如果使用内核的默认配置，则mmap区域的起始点不是随机的。

如果计算机提供了巨大的虚拟地址空间，那么使用上述的地址空间布局
会工作得非常好。但在32位计算机上可能会出问题. 对于每个用户进程
其虚拟地址空间从0到0xc0000000,有3GB可用. TASK_UNMAPPED_BASE
起始于0x40000000, 即1GB处.糟糕的是，堆只有1GB空间可用继续增长
会进入到mmap区域. 问题在于内存映射区域位于虚拟地址空间中间.
从2.6.7引入了一个新的虚拟地址空间布局.

https://github.com/novelinux/linux-4.x.y/tree/master/mm/mmap.c/res/new_layout.jpg

其目的在于使用固定值限制栈的最大长度. 由于栈是有界的，因此安置
内存映射的区域可以在栈末端的下方开始.与经典方法相反，改区域现在
是自顶向下扩展。由于堆仍然位于虚拟地址空间中较低的区域并向上
增长，因此mmap区域和堆区域可以相对扩展，直至耗尽虚拟地址空间中
剩余的区域。为确保栈和mmap区域不发生冲突，在两者之间设置一个
安全间隙.
