# Linux 中直接 I/O 机制的介绍

对于传统的操作系统来说，普通的 I/O 操作一般会被内核缓存，这种 I/O 被称作缓存 I/O。
本文所介绍的文件访问机制不经过操作系统内核的缓存，数据直接在磁盘和应用程序地址空间进行传输，
所以该文件访问的机制称作为直接 I/O。Linux 中就提供了这样一种文件访问机制，对于那种将 I/O
缓存存放在用户地址空间的应用程序来说，直接 I/O 是一种非常高效的手段。
本文将基于 2.6.18 版本的内核来讨论 Linux 中直接 I/O 的技术的设计与实现。

## 直接 I/O 的动机

在介绍直接 I/O 之前，这一小节先介绍一下为什么会出现直接 I/O 这种机制，即传统的 I/O 操作存在哪些缺点。

### 什么是缓存 I/O (Buffered I/O)

缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，
操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作
系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。缓存 I/O 有以下这些优点：
缓存 I/O 使用了操作系统内核缓冲区，在一定程度上分离了应用程序空间和实际的物理设备。
缓存 I/O 可以减少读盘的次数，从而提高性能。
当应用程序尝试读取某块数据的时候，如果这块数据已经存放在了页缓存中，那么这块数据就可以立即返回给应用程序，
而不需要经过实际的物理读盘操作。当然，如果数据在应用程序读取之前并未被存放在页缓存中，那么就需要先将
数据从磁盘读到页缓存中去。对于写操作来说，应用程序也会将数据先写到页缓存中去，数据是否被立即写到磁盘上
去取决于应用程序所采用的写操作机制：如果用户采用的是同步写机制（ synchronous writes ）, 那么数据会
立即被写回到磁盘上，应用程序会一直等到数据被写完为止；如果用户采用的是延迟写机制（ deferred writes ），
那么应用程序就完全不需要等到数据全部被写回到磁盘，数据只要被写到页缓存中去就可以了。在延迟写机制的情况下，
操作系统会定期地将放在页缓存中的数据刷到磁盘上。与异步写机制（ asynchronous writes ）不同的是，
延迟写机制在数据完全写到磁盘上的时候不会通知应用程序，而异步写机制在数据完全写到磁盘上的时候是会返回给应用程序的。
所以延迟写机制本身是存在数据丢失的风险的，而异步写机制则不会有这方面的担心。

* 缓存 I/O 的缺点

在缓存 I/O 机制中，DMA 方式可以将数据直接从磁盘读到页缓存中，或者将数据从页缓存直接写回到磁盘上，
而不能直接在应用程序地址空间和磁盘之间进行数据传输，这样的话，数据在传输过程中需要在应用程序地址
空间和页缓存之间进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。
对于某些特殊的应用程序来说，避开操作系统内核缓冲区而直接在应用程序地址空间和磁盘之间传输数据会比使用
操作系统内核缓冲区获取更好的性能，下边这一小节中提到的自缓存应用程序就是其中的一种。

## 自缓存应用程序（ self-caching applications）

对于某些应用程序来说，它会有它自己的数据缓存机制，比如，它会将数据缓存在应用程序地址空间，
这类应用程序完全不需要使用操作系统内核中的高速缓冲存储器，这类应用程序就被称作是
自缓存应用程序（ self-caching applications ）。数据库管理系统是这类应用程序的一个代表。
自缓存应用程序倾向于使用数据的逻辑表达方式，而非物理表达方式；当系统内存较低的时候，
自缓存应用程序会让这种数据的逻辑缓存被换出，而并非是磁盘上实际的数据被换出。自缓存
应用程序对要操作的数据的语义了如指掌，所以它可以采用更加高效的缓存替换算法。自缓存应用程序
有可能会在多台主机之间共享一块内存，那么自缓存应用程序就需要提供一种能够有效地将用户地址空间的
缓存数据置为无效的机制，从而确保应用程序地址空间缓存数据的一致性。

对于自缓存应用程序来说，缓存 I/O 明显不是一个好的选择。由此引出我们这篇文章着重要介绍的 Linux 中的直接 I/O 技术。
Linux 中的直接 I/O 技术非常适用于自缓存这类应用程序，该技术省略掉缓存 I/O 技术中操作系统内核缓冲区的使用，
数据直接在应用程序地址空间和磁盘之间进行传输，从而使得自缓存应用程序可以省略掉复杂的系统级别的缓存结构，
而执行程序自己定义的数据读写管理，从而降低系统级别的管理对应用程序访问数据的影响。
在下面一节中，我们会着重介绍 Linux 中提供的直接 I/O 机制的设计与实现，该机制为自缓存应用程序提供了很好的支持。

## Linux 2.6 中的直接 I/O 技术

Linux 2.6 中提供的几种文件访问方式
所有的 I/O 操作都是通过读文件或者写文件来完成的。在这里，我们把所有的外围设备，包括键盘和显示器，
都看成是文件系统中的文件。访问文件的方法多种多样，这里列出下边这几种 Linux 2.6 中支持的文件访问方式。

```
标识符名	标识符描述
O_RDONLY	以只读的方式打开文件
O_WRONLY	以只写的方式打开文件
O_RDWR	以读写的方式打开文件
O_CREAT	若文件不存在，则创建该文件
O_EXCL	以独占模式打开文件；若同时设置 O_EXCL 和 O_CREATE, 那么若文件已经存在，则打开操作会失败
O_NOCTTY	若设置该描述符，则该文件不可以被当成终端处理
O_TRUNC	截断文件，若文件存在，则删除该文件
O_APPEND	若设置了该描述符，则在写文件之前，文件指针会被设置到文件的底部
O_NONBLOCK	以非阻塞的方式打开文件
O_NELAY	同 O_NELAY，若同时设置 O_NELAY 和 O_NONBLOCK，O_NONBLOCK 优先起作用
O_SYNC	该描述符会对普通文件的写操作产生影响，若设置了该描述符，则对该文件的写操作会等到数据被写到磁盘上才算结束
FASYNC	若设置该描述符，则 I/O 事件通知是通过信号发出的
O_DIRECT	该描述符提供对直接 I/O 的支持
O_LARGEFILE	该描述符提供对超过 2GB 大文件的支持
O_DIRECTORY	该描述符表明所打开的文件必须是目录，否则打开操作失败
O_NOFOLLOW	若设置该描述符，则不解析路径名尾部的符号链接
```

### 直接 I/O 的优点

直接 I/O 最主要的优点就是通过减少操作系统内核缓冲区和应用程序地址空间的数据拷贝次数，
降低了对文件读取和写入时所带来的 CPU 的使用以及内存带宽的占用。这对于某些特殊的应用程序，
比如自缓存应用程序来说，不失为一种好的选择。如果要传输的数据量很大，使用直接 I/O
的方式进行数据传输，而不需要操作系统内核地址空间拷贝数据操作的参与，这将会大大提高性能。

### 直接 I/O 潜在可能存在的问题

直接 I/O 并不一定总能提供令人满意的性能上的飞跃。设置直接 I/O 的开销非常大，
而直接 I/O 又不能提供缓存 I/O 的优势。缓存 I/O 的读操作可以从高速缓冲存储器中获取数据，
而直接 I/O 的读数据操作会造成磁盘的同步读，这会带来性能上的差异 , 并且导致进程需要较长的
时间才能执行完；对于写数据操作来说，使用直接 I/O 需要 write() 系统调用同步执行，
否则应用程序将会不知道什么时候才能够再次使用它的 I/O 缓冲区。与直接 I/O 读操作类似的是，
直接 I/O 写操作也会导致应用程序关闭缓慢。所以，应用程序使用直接 I/O 进行数据传输的时候通常会和使用异步 I/O 结合使用。

## 总结

Linux 中的直接 I/O 访问文件方式可以减少 CPU 的使用率以及内存带宽的占用，
但是直接 I/O 有时候也会对性能产生负面影响。所以在使用直接 I/O 之前一定要
对应用程序有一个很清醒的认识，只有在确定了设置缓冲 I/O 的开销非常巨大的情况下，
才考虑使用直接 I/O。直接 I/O 经常需要跟异步 I/O 结合起来使用，本文对异步 I/O 没有作详细介绍，
有兴趣的读者可以参看 Linux 2.6 中相关的文档介绍。